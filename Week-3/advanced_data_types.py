#list-mutable ie you can edit it
fruits=["mango","oranges"]
friends=["mark","anita","leon"]
#for empty list friends =[]
#for add-->append , exte
students=["marie","kigen","george"]
friends.extend(students)
friends.append("")
pop, del-->remove from list
friend.sort
friends.remove
#tuples-->(immutable)--> a type of list that is immutable
stationeries=("pens","ink","sharpener","books")
#but you can replace the whole tuple
"ruler","pencil"
for stationery in stationeries:
    print(stationery)
numbers=(1,2,3,4,5,6,7,8,9)

            
#dictionary--> ie dic, uses key and value pair.stores values with key and pairs- uses curly brackets
student={"name":"vincent","age":24,"gender":"male"}
print(student["name"])
print(student["age"])
print(student["gender"])
print(student["is_tall"])
#SETS-->collectio of items
my_set={"banana","apple","oranges"}
#remember in dictionary we were using key and values but set does not have that and you can access it the same way
my_fruits={"banana","apple","oranges","pineaple"}
my_fruit in fruits
print(fruit)
print(type (my_fruits))
print(len(my_fruits))
# TYPES OF SETS
#orderderd- similar items and non ordered like items={"pencil","2","3",}

#mutable vs immutable
#immutable-->you cannot edit it during the life cycle of the program 
#mutable --> data types that you can edit it during the program life cycle ie add/ delete
#FUNCTIONS
#DATA TIME(PYTHON MODULE)
#OBJECT ORIENTED PROGRAMMING
#MODULES
#PIPS
#FILE HANDLING
